pragma solidity >=0.7.0;

import "hardhat/console.sol";
import "@chainlink/contracts/src/v0.7/ChainlinkClient.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@openzeppelin/contracts/math/SafeMath.sol";
import "../interfaces/IENS.sol";
import "./Root.sol";

contract NFTLDEscrowManager is IERC721Receiver, ChainlinkClient, Ownable {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    ENS public ens;
    uint256 public escrowFee; // fee = trade.amount / escrowFee
    uint256 public constant maxFee = 10; // 10%

    address private hnsOracle;
    bytes32 private verifyHnsTxJobId;
    address private link;
    uint256 private oracleFee = 0.1 * 10 ** 18; // 0.1 LINK

    enum TradeStatus {
      IDLE, // no trade started yet
      DEPOSIT_ESCROWED, // Sale has a committed counterparty
      TRANSFERED, // tld TRANSFER tx sent on HNS
      FINALIZED // tld FINALIZE tx sent on HNS
    }

    struct Trade {
      address from; // seller
      address to; // buyer
      bytes32 hnsFrom; // hns address of seller
      bytes32 hnsTo; // hns address of buyer
      uint256 amount; // # of tokens TODO considerations for non base18 tokens?
      address token; // ETH if address(0)
      uint256[] tldTokens; // all tlds in trade
      TradeStatus status;
    }

    event NewOracle(address oracle, bytes32 jobId);
    event TradeInitiated(address seller, uint256 amount, address token, uint[] indexed tlds);
    event DepositEscrowed(bytes32 tradeId, address buyer, bytes32 indexed hnsTo);
    event TradeFinalized(bytes32 tradeId, bytes32 indexed hnsTo, bytes32 indexed hnsFrom);

    // keccak([NFTLD id, ...ids]) -> Trade
    mapping(bytes32 => Trade) public trades;
    // tradeId -> completed
    // true after chainlink node confirms FINALIZE txs on all tlds hnsFrom -> hnsTo
    mapping(bytes32 -> bool) public finalizedTrades;
    // token adddress -> allowed
    mapping(address => bool) public allowedTokens;
    // LINK run ID -> Trade
    mapping(bytes32 => bytes32) private tradeConfirmations;
    // token address -> fees earned
    mapping(address => uint256) private feesCollected;


    function initializeEscrowManager(ENS _ens, address _oracle, address _link, bytes32 _jobId) internal {
      ens = _ens;
      hnsOracle = _oracle;
      link = _link;
      verifyHnsTxJobId = _jobId;
    }

    /**
     * @dev Lets specified domain buyer or anyone if buyer is not set yet
    */
    modifier onlyBuyer(bytes32 id) {
      Trade memory trade = trades[id];
      require(
        trade.to == address(0) || trade.to == msg.sender,
        'Only domain buyer can call this function'
      );
      _;
    }

    modifier onlySeller(bytes32 id) {
      Trade memory trade = trades[id];
      require(msg.sender == trade.from, 'Only domain seller can call this function');
      _;
    }

    /**
     * @dev TLD seller sets price at which to sell TLD
     * and sends token to this Broker contract until trade is completed or canceled
     * @param ids - NFTLD ids generated by ENS Root contract
     * @param amount - amount of ETH to sell domain for
     * @param token - ERC20 token seller wants to receive
     * @param hnsFrom - hns address that domain is currently held in and will be sent to hnsTo address on TRANSFER/FINALIZE
    */
    function initiateTrade(uint[] calldata ids,  uint amount, address token, bytes32 hnsFrom) public {
      require(allowedTokens[token], 'Must supply allowed RC20 token address'); // TODO figure out best method to verify ERC20
      _initiateTrade(ids, amount, token, msg.sender, hnsFrom, address(0));
    }

    function initiateTradeWithBuyer(uint[] calldata ids, uint amount, address token, bytes32 hnsFrom, address to) public {
      require(allowedTokens[token], 'Must supply allowed ERC20 token address');
      _initiateTrade(ids, amount, token, msg.sender, hnsFrom, to);
    }

    function initiateETHTrade(uint[] calldata ids,  uint amount, bytes32 hnsFrom) public {
      _initiateTrade(ids, amount, address(0), msg.sender, hnsFrom, address(0));
    }

    function initiateETHTradeWithBuyer(uint[] calldata ids, uint amount, bytes32 hnsFrom, address to) public {
      _initiateTrade(ids, amount, address(0), msg.sender, hnsFrom, to);
    }

    /**
     * @dev TLD seller sets price at which to sell TLD
     * and sends token to this Broker contract until trade is completed or canceled
     * @param ids - NFTLD ids generated by ENS Root contract
     * @param amount - amount of ETH to sell domain for
     * @param token - ERC20 token seller wants to receive. addres(0) if native chain toke
     * @param from - ETH address of seller
     * @param hnsFrom - hns address of seller that domain is currently held in and will be sent to hnsTo address on TRANSFER/FINALIZE
     * @param to - ETH address for buyer of tlds. If address(0) anyone can fulfill trade
    */
    function _initiateTrade(uint[] calldata ids, uint amount, address token, address from, bytes32 hnsFrom, address to) internal {
      require(amount > 0, 'Trade must be over 0');
      bytes32 tradeId = _getTradeId(ids);
      require(!_isTradeStarted(tradeId), 'Trade already in progress');

      Root root = _getRoot();
      for (uint i=0; i< ids.length; i++) {
        require(from == root.ownerOf(ids[i]), 'Cannot sell a TLD you dont own');
        root.safeTransferFrom(from, address(this), ids[i]);
      }

      trades[tradeId] = Trade({
        status: TradeStatus.IDLE,
        tlds: ids,
        amount: amount,
        token: token,
        from: from,
        to: to,
        hnsFrom: hnsFrom,
        hsnTo: bytes32(0),
      });

      emit TradeInitiated({
        tlds: ids,
        seller: from,
        amount: amount,
        token: token
      });
    }

    function acceptTrade(bytes32 tradeId, bytes32 hnsTo) public payable onlyBuyer(tradeId) returns (bool) {
      Trade memory trade = trades[tradeId];
      require(trade.status == TradeStatus.IDLE, 'Cannot accept trade already in progress');

      if(trade.token == address(0)) {
        require(msg.value >= trade.amount, 'Insuffient ETH sent for trade');
        if(msg.value > trade.amount) { // return surplus ETH sent
          msg.sender.transfer(msg.value.sub(trade.amount));
        }
      } else {
        IERC20 token = IERC20(trade.token);
        require(token.balanceOf(msg.sender) >= trade.amount, 'Insuffient ETH sent for trade');
        token.safeTransferFrom(msg.sender, address(this), trade.amount);
      }

      trade.status = TradeStatus.DEPOSIT_ESCROWED;
      trade.hnsTo = hnsTo;
      if(trade.to == address(0)) {
        // is it more gas efficient to just assign without doing if() ?
        trade.to = msg.sender;
      }

      emit DepositEscrowed({
        buyer: msg.sender,
        tradeId: tradeId,
        hnsTo: hnsTo
      });

      return true;
    }

    /**
      * @dev Called by domain seller after they have submitted a FINALIZE tx on Handshake chain.
      * Chainlink oracle will confirm that FINALIZE tx exists and is from hnsFrom to hnsTo for domain.
      * Oracle is responsible for turning ENS namehash into HNS domain.
      *
      * @param tradeId - trade id from hash of all NFTLD ids in the sale
      * @return requestId - chainlink job run id
     */
    function checkHnsFinalize(bytes32 tradeId) public onlySeller(tradeId) returns (bytes32) {
      Trade memory trade = trades[tradeId];
      require(
        trade.status == TradeStatus.DEPOSIT_ESCROWED,
        'Trade is not ready to FINALIZE'
      );
      return _checkHnsTx(tradeId, trade.hnsFrom, trade.hsTo, this.receiveHnsFinalizeResponse.selector);
    }

    /**
     * @dev calls ChainLink oracle to verify that all TLDs have been transfered from the Trade.hnsFrom
     * to Trade.hnsTo. Smart contract sends tradeId and oracle is calls The Graph to find all associated tlds.
     *
     * 
    */
    function _checkHnsTx(bytes32 tradeId, bytes32 hnsFrom, bytes32 hnsTo, bytes4 callback)
      internal
      returns (bytes32)
    {
      Chainlink.Request memory request = buildChainlinkRequest(
        verifyHnsTxJobId,
        address(this),
        callback
      );
      tradeConfirmations[request.id] = tradeId;


      Chainlink.add(request, "tradeId", _bytes32ToString(tradeId));
      Chainlink.add(request, "txType", "FINALIZE");
      Chainlink.add(request, "from", _bytes32ToString(hnsFrom));
      Chainlink.add(request, "to", _bytes32ToString(hnsTo));
      return sendChainlinkRequestTo(hnsOracle, request, oracleFee);
    }

    function receiveHnsFinalizeResponse(bytes32 requestId, bool finalized)
      public
      recordChainlinkFulfillment(requestId)
      returns (bool)
    {
      if(finalized) {
        finalizedTrades[tradeConfirmations[requestId]] = true;
        // or 
        // Trade memory trade = trades[tradeConfirmations[requestId]];
        // trade.status = TradeStatus.FINALIZED;
      }
      return finalized;
    }

    function finalizeTrade(bytes32 tradeId) public returns (bool) {
      require(finalizedTrades[tradeId], 'Trade has not been finalized');
      return _finalizeTrade(tradeId);;
    }

    function _finalizeTrade(bytes32 tradeId) internal returns (bool) {
      Trade memory trade = trades[tradeId];
      Root root = _getRoot();
      uint256 fee = trade.amount.div(escrowFee);
      if(trade.token == address(0)) {
        require(address(this).balance >= trade.amount, 'oops');
        address(this).transfer(fee);
        payable(trade.from).transfer(trade.amount - fee);
      } else {
        IERC20 token = IERC20(trade.token);
        require(token.balanceOf(address(this)) >= trade.amount, 'oops');
        token.transer(trade.from, trade.amount.sub(fee));
      }
      withdrawable[trade.token] += fee;
 
      emit TradeFinalized({
        tradeId: tradeId,
        hnsTo: trade.hnsTo,
        hnsFrom: trade.hnsFrom
      });

      delete trades[tradeId];
      delete finalizedTrades[tradeId];
      return true;
    }


    /**
     * @dev Allows TLD seller to retrieve NFTLDs if sale hast started yet.
     * @param tradeId - hash of NFTLD ids in trade
    */
    function cancelTrade(bytes32 tradeId) public virtual onlySeller(tradeId) returns (bool) {
      require(!_isTradeStarted(tradeId), 'Cannot cancel trade in progress');
      Trade memory trade = trades[tradeId];
      
      Root root = _getRoot();
      for (uint i=0; i< trade.ids.length; i++) {
        root.transfer(address(this), trade.from, trade.ids[i]);
      }
      delete trades[tradeId]; // data should be stored in `trade` var still
      return true;
    }

    /**
     * @dev only callable by buyer to prevent griefing by seller if tey never transfer domain on HNS.
     * Sends escrowed assets back to original owners.
     * Only callable after `saleTTL` has expired.
     * @param  id - token id being sold
    */
    function fuckOff(bytes32 tradeId) public onlyBuyer(tradeId) returns (bool) {
      require(_isSaleStarted(tradeId), 'Trade has not started yet');
      Trade memory trade = trades[tradeId];
      // add startTime to Trade and saleTTL global var
      // require(trade.startTime + saleTTL >= block.timestamp, 'can not fuck off yet');


      _getRoot().safeTransferFrom(address(this), trade.from, id);
      payable(trade.to).transfer(trade.amount); // should be sale.buyer but .call.calue/.transfer dont compile

      delete trades[tradeId];
      return true;
    }

    /** OWNER FUNCTIONS */
    function setTokenTradability(address _token, bool _allowed) public virtual onlyOwner returns (bool) {
      require(IERC20(_token), 'Token is not an ERC20');
      allowedTokens[_token] = _allowed;
      return true;
    }
    function setEscrowFee(uint256 _escrowFee) public virtual onlyOwner returns (bool) {
      require(_escrowFee >= maxFee, 'Fee too high'); // > because denominator
      escrowFee = _escrowFee;
      return true;
    }

    function setOracle(address _oracle, uint256 _fee, bytes32 _jobId) public virtual onlyOwner returns (bool) {
      hnsOracle = _oracle;
      oracleFee= _fee;
      verifyHnsTxJobId = _jobId;
      return true;
    }

    function withdrawETH(uint256 _amount, address _to) public virtual onlyOwner returns (bool) {
      require(address(this).balance >= _amount, 'Insufficient ETH balance');
      withdrawable[address(0)] -= _amount;
      payable(_to).transfer(_amount);
      return true;
    }

    function withdrawToken(uint256 _amount, address _token, address _to) public virtual onlyOwner returns (bool) {
      require(wthdrawable[_token] >= _amount, 'Withdrawal amount greater than fees accured');
      IERC20 token = IERC20(_token);
      require(token.balanceOf(address(this)) >= _amount, 'Insufficient token balance');
      withdrawable[trade.token] -0= _amount;
      token.transfer(_to, _amount);
      return true;
    }

     /** HELPER FUNCTIONS */
    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {
      return this.onERC721Received.selector;
    }


    /** @dev NFTLD ids. Array must have same order and size generate equal hashes */
    function _getTradeId(uint[] calldata ids) public pure returns (bytes32) {
      return keccak256(ids);
    }
    
    /** @dev Gets NFTLDs being traded in  tradeId */
    function _getTradeNFTLDs(bytes32 tradeId) public view returns (uint[] calldata) {
      return trades[tradeId].tldTokens;
    }

    function _getRoot() internal view returns(Root) {
      return Root(ens.owner(bytes32(0)));
    }

    function _isTradeStarted(bytes32 id) internal virtual view returns (bool) {
      Trade memory trade = trades[id];
      return trade.hnsTo != bytes32(0); // set once buyer deposits escrow (idk how enum acts when Trade isnt present)
    }

    function _bytes32ToString(bytes32 _bytes32) public pure returns (string memory) {
      uint8 i = 0;
      while(i < 32 && _bytes32[i] != 0) {
          i++;
      }
      bytes memory bytesArray = new bytes(i);
      for (i = 0; i < 32 && _bytes32[i] != 0; i++) {
          bytesArray[i] = _bytes32[i];
      }
      return string(bytesArray);
    }
}
